Обновляем версию если используем как модуль 
import (
    "testingconfig"
)

go get testingconfig@latest

вывод простой ... общего пакета не будет :)
это будет шаблон
правим 
tomlConfig.go
configuration.go

тут приватно хранится единичный экземпляр конфиг структура
type config struct {
	*Configuration
	viper *viper.Viper
}
var cfg *config = nil
тут имя конфиг файла с расширением .toml
var ConfigFileName = ""
имя по умолчанию файла конфига
var defaultConfigName = "config"

инициализируем конфиг вызовом
func GetInstance(cfgName string, dbg ...string)

можно инициализировать вызовом модуля метода Get()
укороченный вызов когда не важно имя конфига и другое
имя будет по умолчанию config.toml

сначала читаем файл если есть помещаем в конфиг структуру, и мержим с переменной пакета



попробуем так
создадим ветку dev
git checkout -b dev
пушим заодно и ветку dev
git push github

получаем вот такой способ в итоге модуль на гитхабе
а настройка такая
делаем файл такой примерно содержания

var tomlConfig = []byte(`
# This is a TOML document.
name = "App merge declaration"
hostname = "localhost"
hostport = "3600"
debug = true
isadmin = false
browser = ""
`)

type configuration struct {
	Name     string `json:"name"`
	Hostname string `json:"hostname"`
	HostPort string `json:"hostport"`
	Debug    bool   `json:"debug"`
	IsAdmin  bool   `json:"isadmin"`
	Browser  string `json:"browser"`
	// Alcohelp2 bool                  `json:"alcohelp2"`
	// Database   DatabaseConfiguration   `json:"database"`
	// Database   DatabaseConfiguration   `json:"database"`
	// Logging    LoggingConfiguration    `json:"logging"`
	// Web        WebConfiguration        `json:"web"`
	// Version    Version                 `json:"version"`
	// Gui        GuiGonfiguration        `json:"gui"`
	// Declaracia DeclaraciaConfiguration `json:"declaracia"`
}

подключаем модуль 	"testingconfig"

// устанавливаем свою структуру конфига для загрузки из файла
var conf = &configuration{}

// устанавливаем свой томл конфиг по умолчанию
config.TomlConfig = tomlConfig

// может сохранить для последующего использования ссылку из метода config.GetInstance
cfg, err := config.GetInstance("config", conf, "debug")
if err != nil {
  fmt.Printf("error = %v\n", err.Error())
  os.Exit(1)
}
fmt.Printf("cfg = %+v\n", cfg.Configuration)

// там мы получаем структуру конфигурации из файла
cfg.Configuration

// после инициализации модуля через config.TomlConfig = tomlConfig и config.GetInstance("config", conf, "debug")
// можно получить ссылку на глобальный объект так
config.Get() // *config.Config
далее сложнее, config.Get().Configuration дает интерфейс и прямо из него не получить последней
можно привести его к типу config.Get().Configuration.(configuration) локального приложения
или же при инициализации модуля структуру переданную для маршалинга сохранять в приложении, тогда там будут данные как структура
хотя можно через Viper получить ее через маршалинг, но это надо мастерить вызов локально...
config.Get().Viper.Unmarshal(configuration)
